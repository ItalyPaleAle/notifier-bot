/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
    '/v3/attachments/{attachmentId}': {
        /** Get AttachmentInfo structure describing the attachment views */
        get: operations['Attachments_GetAttachmentInfo']
    }
    '/v3/attachments/{attachmentId}/views/{viewId}': {
        /** Get the named view as binary content */
        get: operations['Attachments_GetAttachment']
    }
    '/v3/conversations': {
        /**
         * List the Conversations in which this bot has participated.
         *
         * GET from this method with a skip token
         *
         * The return value is a ConversationsResult, which contains an array of ConversationMembers and a skip token.  If the skip token is not empty, then
         * there are further values to be returned. Call this method again with the returned token to get more values.
         *
         * Each ConversationMembers object contains the ID of the conversation and an array of ChannelAccounts that describe the members of the conversation.
         */
        get: operations['Conversations_GetConversations']
        /**
         * Create a new Conversation.
         *
         * POST to this method with a
         * * Bot being the bot creating the conversation
         * * IsGroup set to true if this is not a direct message (default is false)
         * * Array containing the members to include in the conversation
         *
         * The return value is a ResourceResponse which contains a conversation id which is suitable for use
         * in the message payload and REST API uris.
         *
         * Most channels only support the semantics of bots initiating a direct message conversation.  An example of how to do that would be:
         *
         * ```
         * var resource = await connector.conversations.CreateConversation(new ConversationParameters(){ Bot = bot, members = new ChannelAccount[] { new ChannelAccount("user1") } );
         * await connect.Conversations.SendToConversationAsync(resource.Id, new Activity() ... ) ;
         *
         * ```
         */
        post: operations['Conversations_CreateConversation']
    }
    '/v3/conversations/{conversationId}/activities': {
        /**
         * This method allows you to send an activity to the end of a conversation.
         *
         * This is slightly different from ReplyToActivity().
         * * SendToConversation(conversationId) - will append the activity to the end of the conversation according to the timestamp or semantics of the channel.
         * * ReplyToActivity(conversationId,ActivityId) - adds the activity as a reply to another activity, if the channel supports it. If the channel does not support nested replies, ReplyToActivity falls back to SendToConversation.
         *
         * Use ReplyToActivity when replying to a specific activity in the conversation.
         *
         * Use SendToConversation in all other cases.
         */
        post: operations['Conversations_SendToConversation']
    }
    '/v3/conversations/{conversationId}/activities/history': {
        /**
         * This method allows you to upload the historic activities to the conversation.
         *
         * Sender must ensure that the historic activities have unique ids and appropriate timestamps. The ids are used by the client to deal with duplicate activities and the timestamps are used by the client to render the activities in the right order.
         */
        post: operations['Conversations_SendConversationHistory']
    }
    '/v3/conversations/{conversationId}/activities/{activityId}': {
        /**
         * Edit an existing activity.
         *
         * Some channels allow you to edit an existing activity to reflect the new state of a bot conversation.
         *
         * For example, you can remove buttons after someone has clicked "Approve" button.
         */
        put: operations['Conversations_UpdateActivity']
        /**
         * This method allows you to reply to an activity.
         *
         * This is slightly different from SendToConversation().
         * * SendToConversation(conversationId) - will append the activity to the end of the conversation according to the timestamp or semantics of the channel.
         * * ReplyToActivity(conversationId,ActivityId) - adds the activity as a reply to another activity, if the channel supports it. If the channel does not support nested replies, ReplyToActivity falls back to SendToConversation.
         *
         * Use ReplyToActivity when replying to a specific activity in the conversation.
         *
         * Use SendToConversation in all other cases.
         */
        post: operations['Conversations_ReplyToActivity']
        /**
         * Delete an existing activity.
         *
         * Some channels allow you to delete an existing activity, and if successful this method will remove the specified activity.
         */
        delete: operations['Conversations_DeleteActivity']
    }
    '/v3/conversations/{conversationId}/members': {
        /**
         * Enumerate the members of a conversation.
         *
         * This REST API takes a ConversationId and returns an array of ChannelAccount objects representing the members of the conversation.
         */
        get: operations['Conversations_GetConversationMembers']
    }
    '/v3/conversations/{conversationId}/members/{memberId}': {
        /**
         * Get a single member of a conversation.
         *
         * This REST API takes a ConversationId and MemberId and returns a single ChannelAccount object, if that member is found in this conversation.
         */
        get: operations['Conversations_GetConversationMembers']
        /**
         * Deletes a member from a conversation.
         *
         * This REST API takes a ConversationId and a memberId (of type string) and removes that member from the conversation. If that member was the last member
         * of the conversation, the conversation will also be deleted.
         */
        delete: operations['Conversations_DeleteConversationMember']
    }
    '/v3/conversations/{conversationId}/pagedmembers': {
        /**
         * Enumerate the members of a conversation one page at a time.
         *
         * This REST API takes a ConversationId. Optionally a pageSize and/or continuationToken can be provided. It returns a PagedMembersResult, which contains an array
         * of ChannelAccounts representing the members of the conversation and a continuation token that can be used to get more values.
         *
         * One page of ChannelAccounts records are returned with each call. The number of records in a page may vary between channels and calls. The pageSize parameter can be used as
         * a suggestion. If there are no additional results the response will not contain a continuation token. If there are no members in the conversation the Members will be empty or not present in the response.
         *
         * A response to a request that has a continuation token from a prior request may rarely return members from a previous request.
         */
        get: operations['Conversations_GetConversationPagedMembers']
    }
    '/v3/conversations/{conversationId}/activities/{activityId}/members': {
        /**
         * Enumerate the members of an activity.
         *
         * This REST API takes a ConversationId and a ActivityId, returning an array of ChannelAccount objects representing the members of the particular activity in the conversation.
         */
        get: operations['Conversations_GetActivityMembers']
    }
    '/v3/conversations/{conversationId}/attachments': {
        /**
         * Upload an attachment directly into a channel's blob storage.
         *
         * This is useful because it allows you to store data in a compliant store when dealing with enterprises.
         *
         * The response is a ResourceResponse which contains an AttachmentId which is suitable for using with the attachments API.
         */
        post: operations['Conversations_UploadAttachment']
    }
}

export interface definitions {
    /** Metadata for an attachment */
    AttachmentInfo: {
        /** Name of the attachment */
        name?: string
        /** ContentType of the attachment */
        type?: string
        /** attachment views */
        views?: definitions['AttachmentView'][]
    }
    /** Attachment View name and size */
    AttachmentView: {
        /** Id of the attachment */
        viewId?: string
        /** Size of the attachment */
        size?: number
    }
    /** An HTTP API response */
    ErrorResponse: {
        /** Error message */
        error?: definitions['Error']
    }
    /** Object representing error information */
    Error: {
        /** Error code */
        code?: string
        /** Error message */
        message?: string
        /** Error from inner http call */
        innerHttpError?: definitions['InnerHttpError']
    }
    /** Object representing inner http error */
    InnerHttpError: {
        /** HttpStatusCode from failed request */
        statusCode?: number
        /** Body from failed request */
        body?: {[key: string]: any}
    }
    /** Parameters for creating a new conversation */
    ConversationParameters: {
        /** IsGroup */
        isGroup?: boolean
        /** The bot address for this conversation */
        bot?: definitions['ChannelAccount']
        /** Members to add to the conversation */
        members?: definitions['ChannelAccount'][]
        /** (Optional) Topic of the conversation (if supported by the channel) */
        topicName?: string
        /** (Optional) The tenant ID in which the conversation should be created */
        tenantId?: string
        /** (Optional) When creating a new conversation, use this activity as the initial message to the conversation */
        activity?: definitions['Activity']
        /** Channel specific payload for creating the conversation */
        channelData?: {[key: string]: any}
    }
    /** Channel account information needed to route a message */
    ChannelAccount: {
        /** Channel id for the user or bot on this channel (Example: joe@smith.com, or @joesmith or 123456) */
        id?: string
        /** Display friendly name */
        name?: string
        /** This account's object ID within Azure Active Directory (AAD) */
        aadObjectId?: string
        /** Role of the entity behind the account (Example: User, Bot, etc.) */
        role?: definitions['RoleTypes']
    }
    /** An Activity is the basic communication type for the Bot Framework 3.0 protocol. */
    Activity: {
        /** Contains the activity type. */
        type?: definitions['ActivityTypes']
        /** Contains an ID that uniquely identifies the activity on the channel. */
        id?: string
        /** Contains the date and time that the message was sent, in UTC, expressed in ISO-8601 format. */
        timestamp?: string
        /**
         * Contains the local date and time of the message, expressed in ISO-8601 format.
         * For example, 2016-09-23T13:07:49.4714686-07:00.
         */
        localTimestamp?: string
        /**
         * Contains the name of the local timezone of the message, expressed in IANA Time Zone database format.
         * For example, America/Los_Angeles.
         */
        localTimezone?: string
        /**
         * A string containing an IRI identifying the caller of a bot. This field is not intended to be transmitted
         * over the wire, but is instead populated by bots and clients based on cryptographically verifiable data
         * that asserts the identity of the callers (e.g. tokens).
         */
        callerId?: string
        /** Contains the URL that specifies the channel's service endpoint. Set by the channel. */
        serviceUrl?: string
        /** Contains an ID that uniquely identifies the channel. Set by the channel. */
        channelId?: string
        /** Identifies the sender of the message. */
        from?: definitions['ChannelAccount']
        /** Identifies the conversation to which the activity belongs. */
        conversation?: definitions['ConversationAccount']
        /** Identifies the recipient of the message. */
        recipient?: definitions['ChannelAccount']
        /** Format of text fields Default:markdown */
        textFormat?: definitions['TextFormatTypes']
        /** The layout hint for multiple attachments. Default: list. */
        attachmentLayout?: definitions['AttachmentLayoutTypes']
        /** The collection of members added to the conversation. */
        membersAdded?: definitions['ChannelAccount'][]
        /** The collection of members removed from the conversation. */
        membersRemoved?: definitions['ChannelAccount'][]
        /** The collection of reactions added to the conversation. */
        reactionsAdded?: definitions['MessageReaction'][]
        /** The collection of reactions removed from the conversation. */
        reactionsRemoved?: definitions['MessageReaction'][]
        /** The updated topic name of the conversation. */
        topicName?: string
        /** Indicates whether the prior history of the channel is disclosed. */
        historyDisclosed?: boolean
        /** A BCP-47 locale name for the contents of the text field. */
        locale?: string
        /** The text content of the message. */
        text?: string
        /** The text to speak. */
        speak?: string
        /**
         * Indicates whether your bot is accepting,
         * expecting, or ignoring user input after the message is delivered to the client.
         */
        inputHint?: definitions['InputHints']
        /** The text to display if the channel cannot render cards. */
        summary?: string
        /** The suggested actions for the activity. */
        suggestedActions?: definitions['SuggestedActions']
        /** Attachments */
        attachments?: definitions['Attachment'][]
        /** Represents the entities that were mentioned in the message. */
        entities?: definitions['Entity'][]
        /** Contains channel-specific content. */
        channelData?: {[key: string]: any}
        /** Indicates whether the recipient of a contactRelationUpdate was added or removed from the sender's contact list. */
        action?: string
        /** Contains the ID of the message to which this message is a reply. */
        replyToId?: string
        /** A descriptive label for the activity. */
        label?: string
        /** The type of the activity's value object. */
        valueType?: string
        /** A value that is associated with the activity. */
        value?: {[key: string]: any}
        /** The name of the operation associated with an invoke or event activity. */
        name?: string
        /** A reference to another conversation or activity. */
        relatesTo?: definitions['ConversationReference']
        /** The a code for endOfConversation activities that indicates why the conversation ended. */
        code?: definitions['EndOfConversationCodes']
        /** The time at which the activity should be considered to be "expired" and should not be presented to the recipient. */
        expiration?: string
        /** The importance of the activity. */
        importance?: definitions['ActivityImportance']
        /**
         * A delivery hint to signal to the recipient alternate delivery paths for the activity.
         * The default delivery mode is "default".
         */
        deliveryMode?: definitions['DeliveryModes']
        /** List of phrases and references that speech and language priming systems should listen for */
        listenFor?: string[]
        /** The collection of text fragments to highlight when the activity contains a ReplyToId value. */
        textHighlights?: definitions['TextHighlight'][]
        /** An optional programmatic action accompanying this request */
        semanticAction?: definitions['SemanticAction']
    }
    /** Conversation account represents the identity of the conversation within a channel */
    ConversationAccount: {
        /** Indicates whether the conversation contains more than two participants at the time the activity was generated */
        isGroup?: boolean
        /** Indicates the type of the conversation in channels that distinguish between conversation types */
        conversationType?: string
        /** This conversation's tenant ID */
        tenantId?: string
        /** Channel id for the user or bot on this channel (Example: joe@smith.com, or @joesmith or 123456) */
        id?: string
        /** Display friendly name */
        name?: string
        /** This account's object ID within Azure Active Directory (AAD) */
        aadObjectId?: string
        /** Role of the entity behind the account (Example: User, Bot, etc.) */
        role?: definitions['RoleTypes']
    }
    /** Message reaction object */
    MessageReaction: {
        /** Message reaction type */
        type?: definitions['MessageReactionTypes']
    }
    /** SuggestedActions that can be performed */
    SuggestedActions: {
        /** Ids of the recipients that the actions should be shown to.  These Ids are relative to the channelId and a subset of all recipients of the activity */
        to?: string[]
        /** Actions that can be shown to the user */
        actions?: definitions['CardAction'][]
    }
    /** An attachment within an activity */
    Attachment: {
        /** mimetype/Contenttype for the file */
        contentType?: string
        /** Content Url */
        contentUrl?: string
        /** Embedded content */
        content?: {[key: string]: any}
        /** (OPTIONAL) The name of the attachment */
        name?: string
        /** (OPTIONAL) Thumbnail associated with attachment */
        thumbnailUrl?: string
    }
    /** Metadata object pertaining to an activity */
    Entity: {
        /** Type of this entity (RFC 3987 IRI) */
        type?: string
    }
    /** An object relating to a particular point in a conversation */
    ConversationReference: {
        /** (Optional) ID of the activity to refer to */
        activityId?: string
        /** (Optional) User participating in this conversation */
        user?: definitions['ChannelAccount']
        /** (Optional) Bot participating in this conversation */
        bot?: definitions['ChannelAccount']
        /** Reference to the conversation */
        conversation?: definitions['ConversationAccount']
        /** ID of the channel in which the referenced conversation exists */
        channelId?: string
        /** (Optional) Service endpoint where operations concerning the referenced conversation may be performed */
        serviceUrl?: string
        /** (Optional) A BCP-47 locale name for the referenced conversation */
        locale?: string
    }
    /** Refers to a substring of content within another field */
    TextHighlight: {
        /** Defines the snippet of text to highlight */
        text?: string
        /** Occurrence of the text field within the referenced text, if multiple exist. */
        occurrence?: number
    }
    /** Represents a reference to a programmatic action */
    SemanticAction: {
        /** State of this action. Allowed values: `start`, `continue`, `done` */
        state?: definitions['SemanticActionStates']
        /** ID of this action */
        id?: string
        /** Entities associated with this action */
        entities?: {[key: string]: definitions['Entity']}
    }
    /** A clickable action */
    CardAction: {
        /** The type of action implemented by this button */
        type?: definitions['ActionTypes']
        /** Text description which appears on the button */
        title?: string
        /** Image URL which will appear on the button, next to text label */
        image?: string
        /** Alternate text to be used for the Image property */
        imageAltText?: string
        /** Text for this action */
        text?: string
        /** (Optional) text to display in the chat feed if the button is clicked */
        displayText?: string
        /** Supplementary parameter for action. Content of this property depends on the ActionType */
        value?: {[key: string]: any}
        /** Channel-specific data associated with this action */
        channelData?: {[key: string]: any}
    }
    /** A response containing a resource */
    ConversationResourceResponse: {
        /** ID of the Activity (if sent) */
        activityId?: string
        /** Service endpoint where operations concerning the conversation may be performed */
        serviceUrl?: string
        /** Id of the resource */
        id?: string
    }
    /** Conversations result */
    ConversationsResult: {
        /** Paging token */
        continuationToken?: string
        /** List of conversations */
        conversations?: definitions['ConversationMembers'][]
    }
    /** Conversation and its members */
    ConversationMembers: {
        /** Conversation ID */
        id?: string
        /** List of members in this conversation */
        members?: definitions['ChannelAccount'][]
    }
    /** A response containing a resource ID */
    ResourceResponse: {
        /** Id of the resource */
        id?: string
    }
    /** Transcript */
    Transcript: {
        /** A collection of Activities that conforms to the Transcript schema. */
        activities?: definitions['Activity'][]
    }
    /** Page of members. */
    PagedMembersResult: {
        /** Paging token */
        continuationToken?: string
        /** The Channel Accounts. */
        members?: definitions['ChannelAccount'][]
    }
    /** Attachment data */
    AttachmentData: {
        /** Content-Type of the attachment */
        type?: string
        /** Name of the attachment */
        name?: string
        /** Attachment content */
        originalBase64?: string
        /** Attachment thumbnail */
        thumbnailBase64?: string
    }
    /** A Hero card (card with a single, large image) */
    HeroCard: {
        /** Title of the card */
        title?: string
        /** Subtitle of the card */
        subtitle?: string
        /** Text for the card */
        text?: string
        /** Array of images for the card */
        images?: definitions['CardImage'][]
        /** Set of actions applicable to the current card */
        buttons?: definitions['CardAction'][]
        /** This action will be activated when user taps on the card itself */
        tap?: definitions['CardAction']
    }
    /** An image on a card */
    CardImage: {
        /** URL thumbnail image for major content property */
        url?: string
        /** Image description intended for screen readers */
        alt?: string
        /** Action assigned to specific Attachment */
        tap?: definitions['CardAction']
    }
    /** An animation card (Ex: gif or short video clip) */
    AnimationCard: {
        /** Title of this card */
        title?: string
        /** Subtitle of this card */
        subtitle?: string
        /** Text of this card */
        text?: string
        /** Thumbnail placeholder */
        image?: definitions['ThumbnailUrl']
        /** Media URLs for this card. When this field contains more than one URL, each URL is an alternative format of the same content. */
        media?: definitions['MediaUrl'][]
        /** Actions on this card */
        buttons?: definitions['CardAction'][]
        /** This content may be shared with others (default:true) */
        shareable?: boolean
        /** Should the client loop playback at end of content (default:true) */
        autoloop?: boolean
        /** Should the client automatically start playback of media in this card (default:true) */
        autostart?: boolean
        /** Aspect ratio of thumbnail/media placeholder. Allowed values are "16:9" and "4:3" */
        aspect?: string
        /** Describes the length of the media content without requiring a receiver to open the content. Formatted as an ISO 8601 Duration field. */
        duration?: string
        /** Supplementary parameter for this card */
        value?: {[key: string]: any}
    }
    /** Thumbnail URL */
    ThumbnailUrl: {
        /** URL pointing to the thumbnail to use for media content */
        url?: string
        /** HTML alt text to include on this thumbnail image */
        alt?: string
    }
    /** Media URL */
    MediaUrl: {
        /** Url for the media */
        url?: string
        /** Optional profile hint to the client to differentiate multiple MediaUrl objects from each other */
        profile?: string
    }
    /** Audio card */
    AudioCard: {
        /** Title of this card */
        title?: string
        /** Subtitle of this card */
        subtitle?: string
        /** Text of this card */
        text?: string
        /** Thumbnail placeholder */
        image?: definitions['ThumbnailUrl']
        /** Media URLs for this card. When this field contains more than one URL, each URL is an alternative format of the same content. */
        media?: definitions['MediaUrl'][]
        /** Actions on this card */
        buttons?: definitions['CardAction'][]
        /** This content may be shared with others (default:true) */
        shareable?: boolean
        /** Should the client loop playback at end of content (default:true) */
        autoloop?: boolean
        /** Should the client automatically start playback of media in this card (default:true) */
        autostart?: boolean
        /** Aspect ratio of thumbnail/media placeholder. Allowed values are "16:9" and "4:3" */
        aspect?: string
        /** Describes the length of the media content without requiring a receiver to open the content. Formatted as an ISO 8601 Duration field. */
        duration?: string
        /** Supplementary parameter for this card */
        value?: {[key: string]: any}
    }
    /** A basic card */
    BasicCard: {
        /** Title of the card */
        title?: string
        /** Subtitle of the card */
        subtitle?: string
        /** Text for the card */
        text?: string
        /** Array of images for the card */
        images?: definitions['CardImage'][]
        /** Set of actions applicable to the current card */
        buttons?: definitions['CardAction'][]
        /** This action will be activated when user taps on the card itself */
        tap?: definitions['CardAction']
    }
    /** Media card */
    MediaCard: {
        /** Title of this card */
        title?: string
        /** Subtitle of this card */
        subtitle?: string
        /** Text of this card */
        text?: string
        /** Thumbnail placeholder */
        image?: definitions['ThumbnailUrl']
        /** Media URLs for this card. When this field contains more than one URL, each URL is an alternative format of the same content. */
        media?: definitions['MediaUrl'][]
        /** Actions on this card */
        buttons?: definitions['CardAction'][]
        /** This content may be shared with others (default:true) */
        shareable?: boolean
        /** Should the client loop playback at end of content (default:true) */
        autoloop?: boolean
        /** Should the client automatically start playback of media in this card (default:true) */
        autostart?: boolean
        /** Aspect ratio of thumbnail/media placeholder. Allowed values are "16:9" and "4:3" */
        aspect?: string
        /** Describes the length of the media content without requiring a receiver to open the content. Formatted as an ISO 8601 Duration field. */
        duration?: string
        /** Supplementary parameter for this card */
        value?: {[key: string]: any}
    }
    /** A receipt card */
    ReceiptCard: {
        /** Title of the card */
        title?: string
        /** Array of Fact objects */
        facts?: definitions['Fact'][]
        /** Array of Receipt Items */
        items?: definitions['ReceiptItem'][]
        /** This action will be activated when user taps on the card */
        tap?: definitions['CardAction']
        /** Total amount of money paid (or to be paid) */
        total?: string
        /** Total amount of tax paid (or to be paid) */
        tax?: string
        /** Total amount of VAT paid (or to be paid) */
        vat?: string
        /** Set of actions applicable to the current card */
        buttons?: definitions['CardAction'][]
    }
    /**
     * Set of key-value pairs. Advantage of this section is that key and value properties will be
     * rendered with default style information with some delimiter between them. So there is no need for developer to specify style information.
     */
    Fact: {
        /** The key for this Fact */
        key?: string
        /** The value for this Fact */
        value?: string
    }
    /** An item on a receipt card */
    ReceiptItem: {
        /** Title of the Card */
        title?: string
        /** Subtitle appears just below Title field, differs from Title in font styling only */
        subtitle?: string
        /** Text field appears just below subtitle, differs from Subtitle in font styling only */
        text?: string
        /** Image */
        image?: definitions['CardImage']
        /** Amount with currency */
        price?: string
        /** Number of items of given kind */
        quantity?: string
        /** This action will be activated when user taps on the Item bubble. */
        tap?: definitions['CardAction']
    }
    /** A card representing a request to sign in */
    SigninCard: {
        /** Text for signin request */
        text?: string
        /** Action to use to perform signin */
        buttons?: definitions['CardAction'][]
    }
    /** A card representing a request to perform a sign in via OAuth */
    OAuthCard: {
        /** Text for signin request */
        text?: string
        /** The name of the registered connection */
        connectionName?: string
        /** The resource to try to perform token exchange with */
        tokenExchangeResource?: definitions['TokenExchangeResource']
        /** Action to use to perform signin */
        buttons?: definitions['CardAction'][]
    }
    /** Record for a token exchange request that is sent as part of an OAuthCard */
    TokenExchangeResource: {
        /** A unique identifier for this token exchange instance */
        id?: string
        /** The application ID / resource identifier with which to exchange a token on behalf of */
        uri?: string
        /**
         * The identifier of the provider with which to attempt a token exchange
         * A value of null or empty will default to Azure Active Directory
         */
        providerId?: string
    }
    /** A thumbnail card (card with a single, small thumbnail image) */
    ThumbnailCard: {
        /** Title of the card */
        title?: string
        /** Subtitle of the card */
        subtitle?: string
        /** Text for the card */
        text?: string
        /** Array of images for the card */
        images?: definitions['CardImage'][]
        /** Set of actions applicable to the current card */
        buttons?: definitions['CardAction'][]
        /** This action will be activated when user taps on the card itself */
        tap?: definitions['CardAction']
    }
    /** Video card */
    VideoCard: {
        /** Title of this card */
        title?: string
        /** Subtitle of this card */
        subtitle?: string
        /** Text of this card */
        text?: string
        /** Thumbnail placeholder */
        image?: definitions['ThumbnailUrl']
        /** Media URLs for this card. When this field contains more than one URL, each URL is an alternative format of the same content. */
        media?: definitions['MediaUrl'][]
        /** Actions on this card */
        buttons?: definitions['CardAction'][]
        /** This content may be shared with others (default:true) */
        shareable?: boolean
        /** Should the client loop playback at end of content (default:true) */
        autoloop?: boolean
        /** Should the client automatically start playback of media in this card (default:true) */
        autostart?: boolean
        /** Aspect ratio of thumbnail/media placeholder. Allowed values are "16:9" and "4:3" */
        aspect?: string
        /** Describes the length of the media content without requiring a receiver to open the content. Formatted as an ISO 8601 Duration field. */
        duration?: string
        /** Supplementary parameter for this card */
        value?: {[key: string]: any}
    }
    /** GeoCoordinates (entity type: "https://schema.org/GeoCoordinates") */
    GeoCoordinates: {
        /** Elevation of the location [WGS 84](https://en.wikipedia.org/wiki/World_Geodetic_System) */
        elevation?: number
        /** Latitude of the location [WGS 84](https://en.wikipedia.org/wiki/World_Geodetic_System) */
        latitude?: number
        /** Longitude of the location [WGS 84](https://en.wikipedia.org/wiki/World_Geodetic_System) */
        longitude?: number
        /** The type of the thing */
        type?: string
        /** The name of the thing */
        name?: string
    }
    /** Mention information (entity type: "mention") */
    Mention: {
        /** The mentioned user */
        mentioned?: definitions['ChannelAccount']
        /** Sub Text which represents the mention (can be null or empty) */
        text?: string
        /** Type of this entity (RFC 3987 IRI) */
        type?: string
    }
    /** Place (entity type: "https://schema.org/Place") */
    Place: {
        /** Address of the place (may be `string` or complex object of type `PostalAddress`) */
        address?: {[key: string]: any}
        /** Geo coordinates of the place (may be complex object of type `GeoCoordinates` or `GeoShape`) */
        geo?: {[key: string]: any}
        /** Map to the place (may be `string` (URL) or complex object of type `Map`) */
        hasMap?: {[key: string]: any}
        /** The type of the thing */
        type?: string
        /** The name of the thing */
        name?: string
    }
    /** Thing (entity type: "https://schema.org/Thing") */
    Thing: {
        /** The type of the thing */
        type?: string
        /** The name of the thing */
        name?: string
    }
    /** Supplementary parameter for media events */
    MediaEventValue: {
        /** Callback parameter specified in the Value field of the MediaCard that originated this event */
        cardValue?: {[key: string]: any}
    }
    /** A response that includes a user token */
    TokenResponse: {
        /** The channelId of the TokenResponse */
        channelId?: string
        /** The connection name */
        connectionName?: string
        /** The user token */
        token?: string
        /** Expiration for the token, in ISO 8601 format (e.g. "2007-04-05T14:30Z") */
        expiration?: string
    }
    /** A request to exchange a token */
    TokenExchangeInvokeRequest: {
        /** The connection name */
        connectionName?: string
        /** The user token that can be exchanged */
        token?: string
    }
    /** The response object of a token exchange invoke */
    TokenExchangeInvokeResponse: {
        /** The connection name */
        connectionName?: string
        /** The details of why the token exchange failed */
        failureDetail?: string
    }
    /** Contents of the reply to an operation which returns expected Activity replies */
    ExpectedReplies: {
        /** A list of Activities included in the response. */
        activities?: definitions['Activity'][]
    }
    /** Types of Activities */
    ActivityTypes:
        | 'message'
        | 'contactRelationUpdate'
        | 'conversationUpdate'
        | 'typing'
        | 'endOfConversation'
        | 'event'
        | 'invoke'
        | 'deleteUserData'
        | 'messageUpdate'
        | 'messageDelete'
        | 'installationUpdate'
        | 'messageReaction'
        | 'suggestion'
        | 'trace'
        | 'handoff'
    /** Attachment layout types */
    AttachmentLayoutTypes: 'list' | 'carousel'
    /** Indicates whether the semantic action is starting, continuing, or done */
    SemanticActionStates: 'start' | 'continue' | 'done'
    /** Defines action types for clickable buttons. */
    ActionTypes:
        | 'openUrl'
        | 'imBack'
        | 'postBack'
        | 'playAudio'
        | 'playVideo'
        | 'showImage'
        | 'downloadFile'
        | 'signin'
        | 'call'
        | 'messageBack'
    /** Action types valid for ContactRelationUpdate activities */
    ContactRelationUpdateActionTypes: 'add' | 'remove'
    /** Action types valid for InstallationUpdate activities */
    InstallationUpdateActionTypes: 'add' | 'remove'
    /** Message reaction types */
    MessageReactionTypes: 'like' | 'plusOne'
    /** Text format types */
    TextFormatTypes: 'markdown' | 'plain' | 'xml'
    /** Indicates whether the bot is accepting, expecting, or ignoring input */
    InputHints: 'acceptingInput' | 'ignoringInput' | 'expectingInput'
    /** Codes indicating why a conversation has ended */
    EndOfConversationCodes:
        | 'unknown'
        | 'completedSuccessfully'
        | 'userCancelled'
        | 'botTimedOut'
        | 'botIssuedInvalidMessage'
        | 'channelFailed'
    /** Defines the importance of an Activity */
    ActivityImportance: 'low' | 'normal' | 'high'
    /** Role of the entity behind the account (Example: User, Bot, etc.) */
    RoleTypes: 'user' | 'bot'
    /** Values for deliveryMode field */
    DeliveryModes: 'normal' | 'notification' | 'ephemeral' | 'expectReplies'
}

export interface operations {
    /** Get AttachmentInfo structure describing the attachment views */
    Attachments_GetAttachmentInfo: {
        parameters: {
            path: {
                /** attachment id */
                attachmentId: string
            }
        }
        responses: {
            /**
             * An attachmentInfo object is returned which describes the:
             * * type of the attachment
             * * name of the attachment
             *
             *
             * and an array of views:
             * * Size - size of the object
             * * ViewId - View Id which can be used to fetch a variation on the content (ex: original or thumbnail)
             */
            200: {
                schema: definitions['AttachmentInfo']
            }
            /** The operation failed and the response is an error object describing the status code and failure. */
            default: {
                schema: definitions['ErrorResponse']
            }
        }
    }
    /** Get the named view as binary content */
    Attachments_GetAttachment: {
        parameters: {
            path: {
                /** attachment id */
                attachmentId: string
                /** View id from attachmentInfo */
                viewId: string
            }
        }
        responses: {
            /** Attachment stream */
            200: {
                schema: {[key: string]: any}
            }
            /** The Location header describes where the content is now. */
            301: never
            /** The Location header describes where the content is now. */
            302: never
            /** The operation failed and the response is an error object describing the status code and failure. */
            default: {
                schema: definitions['ErrorResponse']
            }
        }
    }
    /**
     * List the Conversations in which this bot has participated.
     *
     * GET from this method with a skip token
     *
     * The return value is a ConversationsResult, which contains an array of ConversationMembers and a skip token.  If the skip token is not empty, then
     * there are further values to be returned. Call this method again with the returned token to get more values.
     *
     * Each ConversationMembers object contains the ID of the conversation and an array of ChannelAccounts that describe the members of the conversation.
     */
    Conversations_GetConversations: {
        parameters: {
            query: {
                /** skip or continuation token */
                continuationToken?: string
            }
        }
        responses: {
            /**
             * An object will be returned containing
             * * an array (Conversations) of ConversationMembers objects
             * * a continuation token
             *
             * Each ConversationMembers object contains:
             * * the Id of the conversation
             * * an array (Members) of ChannelAccount objects
             */
            200: {
                schema: definitions['ConversationsResult']
            }
            /** The operation failed and the response is an error object describing the status code and failure. */
            default: {
                schema: definitions['ErrorResponse']
            }
        }
    }
    /**
     * Create a new Conversation.
     *
     * POST to this method with a
     * * Bot being the bot creating the conversation
     * * IsGroup set to true if this is not a direct message (default is false)
     * * Array containing the members to include in the conversation
     *
     * The return value is a ResourceResponse which contains a conversation id which is suitable for use
     * in the message payload and REST API uris.
     *
     * Most channels only support the semantics of bots initiating a direct message conversation.  An example of how to do that would be:
     *
     * ```
     * var resource = await connector.conversations.CreateConversation(new ConversationParameters(){ Bot = bot, members = new ChannelAccount[] { new ChannelAccount("user1") } );
     * await connect.Conversations.SendToConversationAsync(resource.Id, new Activity() ... ) ;
     *
     * ```
     */
    Conversations_CreateConversation: {
        parameters: {
            body: {
                /** Parameters to create the conversation from */
                parameters: definitions['ConversationParameters']
            }
        }
        responses: {
            /**
             * An object will be returned containing
             * * the ID for the conversation
             * * ActivityId for the activity if provided.  If ActivityId is null then the channel doesn't support returning resource id's for activity.
             */
            200: {
                schema: definitions['ConversationResourceResponse']
            }
            /**
             * An object will be returned containing
             * * the ID for the conversation
             * * ActivityId for the activity if provided.  If ActivityId is null then the channel doesn't support returning resource id's for activity.
             */
            201: {
                schema: definitions['ConversationResourceResponse']
            }
            /**
             * An object will be returned containing
             * * the ID for the conversation
             * * ActivityId for the activity if provided.  If ActivityId is null then the channel doesn't support returning resource id's for activity.
             */
            202: {
                schema: definitions['ConversationResourceResponse']
            }
            /** The operation failed and the response is an error object describing the status code and failure. */
            default: {
                schema: definitions['ErrorResponse']
            }
        }
    }
    /**
     * This method allows you to send an activity to the end of a conversation.
     *
     * This is slightly different from ReplyToActivity().
     * * SendToConversation(conversationId) - will append the activity to the end of the conversation according to the timestamp or semantics of the channel.
     * * ReplyToActivity(conversationId,ActivityId) - adds the activity as a reply to another activity, if the channel supports it. If the channel does not support nested replies, ReplyToActivity falls back to SendToConversation.
     *
     * Use ReplyToActivity when replying to a specific activity in the conversation.
     *
     * Use SendToConversation in all other cases.
     */
    Conversations_SendToConversation: {
        parameters: {
            path: {
                /** Conversation ID */
                conversationId: string
            }
            body: {
                /** Activity to send */
                activity: definitions['Activity']
            }
        }
        responses: {
            /** An object will be returned containing the ID for the resource. */
            200: {
                schema: definitions['ResourceResponse']
            }
            /** A ResourceResponse object will be returned containing the ID for the resource. */
            201: {
                schema: definitions['ResourceResponse']
            }
            /** An object will be returned containing the ID for the resource. */
            202: {
                schema: definitions['ResourceResponse']
            }
            /** The operation failed and the response is an error object describing the status code and failure. */
            default: {
                schema: definitions['ErrorResponse']
            }
        }
    }
    /**
     * This method allows you to upload the historic activities to the conversation.
     *
     * Sender must ensure that the historic activities have unique ids and appropriate timestamps. The ids are used by the client to deal with duplicate activities and the timestamps are used by the client to render the activities in the right order.
     */
    Conversations_SendConversationHistory: {
        parameters: {
            path: {
                /** Conversation ID */
                conversationId: string
            }
            body: {
                /** Historic activities */
                history: definitions['Transcript']
            }
        }
        responses: {
            /** An object will be returned containing the ID for the resource. */
            200: {
                schema: definitions['ResourceResponse']
            }
            /** A ResourceResponse object will be returned containing the ID for the resource. */
            201: {
                schema: definitions['ResourceResponse']
            }
            /** An object will be returned containing the ID for the resource. */
            202: {
                schema: definitions['ResourceResponse']
            }
            /** The operation failed and the response is an error object describing the status code and failure. */
            default: {
                schema: definitions['ErrorResponse']
            }
        }
    }
    /**
     * Edit an existing activity.
     *
     * Some channels allow you to edit an existing activity to reflect the new state of a bot conversation.
     *
     * For example, you can remove buttons after someone has clicked "Approve" button.
     */
    Conversations_UpdateActivity: {
        parameters: {
            path: {
                /** Conversation ID */
                conversationId: string
                /** activityId to update */
                activityId: string
            }
            body: {
                /** replacement Activity */
                activity: definitions['Activity']
            }
        }
        responses: {
            /** An object will be returned containing the ID for the resource. */
            200: {
                schema: definitions['ResourceResponse']
            }
            /** A ResourceResponse object will be returned containing the ID for the resource. */
            201: {
                schema: definitions['ResourceResponse']
            }
            /** An object will be returned containing the ID for the resource. */
            202: {
                schema: definitions['ResourceResponse']
            }
            /** The operation failed and the response is an error object describing the status code and failure. */
            default: {
                schema: definitions['ErrorResponse']
            }
        }
    }
    /**
     * This method allows you to reply to an activity.
     *
     * This is slightly different from SendToConversation().
     * * SendToConversation(conversationId) - will append the activity to the end of the conversation according to the timestamp or semantics of the channel.
     * * ReplyToActivity(conversationId,ActivityId) - adds the activity as a reply to another activity, if the channel supports it. If the channel does not support nested replies, ReplyToActivity falls back to SendToConversation.
     *
     * Use ReplyToActivity when replying to a specific activity in the conversation.
     *
     * Use SendToConversation in all other cases.
     */
    Conversations_ReplyToActivity: {
        parameters: {
            path: {
                /** Conversation ID */
                conversationId: string
                /** activityId the reply is to (OPTIONAL) */
                activityId: string
            }
            body: {
                /** Activity to send */
                activity: definitions['Activity']
            }
        }
        responses: {
            /** An object will be returned containing the ID for the resource. */
            200: {
                schema: definitions['ResourceResponse']
            }
            /** A ResourceResponse object will be returned containing the ID for the resource. */
            201: {
                schema: definitions['ResourceResponse']
            }
            /** An object will be returned containing the ID for the resource. */
            202: {
                schema: definitions['ResourceResponse']
            }
            /** The operation failed and the response is an error object describing the status code and failure. */
            default: {
                schema: definitions['ErrorResponse']
            }
        }
    }
    /**
     * Delete an existing activity.
     *
     * Some channels allow you to delete an existing activity, and if successful this method will remove the specified activity.
     */
    Conversations_DeleteActivity: {
        parameters: {
            path: {
                /** Conversation ID */
                conversationId: string
                /** activityId to delete */
                activityId: string
            }
        }
        responses: {
            /** The operation succeeded, there is no response. */
            200: unknown
            /** The request has been accepted for processing, but the processing has not been completed */
            202: unknown
            /** The operation failed and the response is an error object describing the status code and failure. */
            default: {
                schema: definitions['ErrorResponse']
            }
        }
    }
    /**
     * Get a single member of a conversation.
     *
     * This REST API takes a ConversationId and MemberId and returns a single ChannelAccount object, if that member is found in this conversation.
     */
    Conversations_GetConversationMembers: {
        parameters: {
            path: {
                /** Conversation ID */
                conversationId: string
                memberId: string
            }
        }
        responses: {
            /**
             * A ChannelAccount which has
             *
             * * id - address on this channel
             * * name - name of the user/bot on this channel
             */
            200: {
                schema: definitions['ChannelAccount']
            }
            /** The operation failed and the response is an error object describing the status code and failure. */
            default: {
                schema: definitions['ErrorResponse']
            }
        }
    }
    /**
     * Deletes a member from a conversation.
     *
     * This REST API takes a ConversationId and a memberId (of type string) and removes that member from the conversation. If that member was the last member
     * of the conversation, the conversation will also be deleted.
     */
    Conversations_DeleteConversationMember: {
        parameters: {
            path: {
                /** Conversation ID */
                conversationId: string
                /** ID of the member to delete from this conversation */
                memberId: string
            }
        }
        responses: {
            /** The operation succeeded, there is no response. */
            200: unknown
            /** The operation succeeded but no content was returned. */
            204: never
            /** The operation failed and the response is an error object describing the status code and failure. */
            default: {
                schema: definitions['ErrorResponse']
            }
        }
    }
    /**
     * Enumerate the members of a conversation one page at a time.
     *
     * This REST API takes a ConversationId. Optionally a pageSize and/or continuationToken can be provided. It returns a PagedMembersResult, which contains an array
     * of ChannelAccounts representing the members of the conversation and a continuation token that can be used to get more values.
     *
     * One page of ChannelAccounts records are returned with each call. The number of records in a page may vary between channels and calls. The pageSize parameter can be used as
     * a suggestion. If there are no additional results the response will not contain a continuation token. If there are no members in the conversation the Members will be empty or not present in the response.
     *
     * A response to a request that has a continuation token from a prior request may rarely return members from a previous request.
     */
    Conversations_GetConversationPagedMembers: {
        parameters: {
            path: {
                /** Conversation ID */
                conversationId: string
            }
            query: {
                /** Suggested page size */
                pageSize?: number
                /** Continuation Token */
                continuationToken?: string
            }
        }
        responses: {
            /** OK */
            200: {
                schema: definitions['PagedMembersResult']
            }
        }
    }
    /**
     * Enumerate the members of an activity.
     *
     * This REST API takes a ConversationId and a ActivityId, returning an array of ChannelAccount objects representing the members of the particular activity in the conversation.
     */
    Conversations_GetActivityMembers: {
        parameters: {
            path: {
                /** Conversation ID */
                conversationId: string
                /** Activity ID */
                activityId: string
            }
        }
        responses: {
            /** An array of ChannelAccount objects */
            200: {
                schema: definitions['ChannelAccount'][]
            }
            /** The operation failed and the response is an error object describing the status code and failure. */
            default: {
                schema: definitions['ErrorResponse']
            }
        }
    }
    /**
     * Upload an attachment directly into a channel's blob storage.
     *
     * This is useful because it allows you to store data in a compliant store when dealing with enterprises.
     *
     * The response is a ResourceResponse which contains an AttachmentId which is suitable for using with the attachments API.
     */
    Conversations_UploadAttachment: {
        parameters: {
            path: {
                /** Conversation ID */
                conversationId: string
            }
            body: {
                /** Attachment data */
                attachmentUpload: definitions['AttachmentData']
            }
        }
        responses: {
            /** An object will be returned containing the ID for the resource. */
            200: {
                schema: definitions['ResourceResponse']
            }
            /** A ResourceResponse object will be returned containing the ID for the resource. */
            201: {
                schema: definitions['ResourceResponse']
            }
            /** An object will be returned containing the ID for the resource. */
            202: {
                schema: definitions['ResourceResponse']
            }
            /** The operation failed and the response is an error object describing the status code and failure. */
            default: {
                schema: definitions['ErrorResponse']
            }
        }
    }
}
